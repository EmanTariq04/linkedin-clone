// import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
// import { fetchCount } from './counter/counterAPI';

// const initialState = {
//   value: null,
//   status: 'idle',
// };

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
// export const incrementAsync = createAsyncThunk(
//   'counter/fetchCount',
//   async (amount) => {
//     const response = await fetchCount(amount);
//     // The value we return becomes the `fulfilled` action payload
//     return response.data;
//   }
// );

// export const userSlice = createSlice({
//   name: 'user',
//   initialState,
// The `reducers` field lets us define reducers and generate associated actions
// reducers: {
//   increment: (state) => {
// Redux Toolkit allows us to write "mutating" logic in reducers. It
// doesn't actually mutate the state because it uses the Immer library,
// which detects changes to a "draft state" and produces a brand new
// immutable state based off those changes
// state.value += 1;
// },
// decrement: (state) => {
//   state.value -= 1;
// },
// Use the PayloadAction type to declare the contents of `action.payload`
//   incrementByAmount: (state, action) => {
//     state.value += action.payload;
//   },
// },
// The `extraReducers` field lets the slice handle actions defined elsewhere,
// including actions generated by createAsyncThunk or in other slices.
//   extraReducers: (builder) => {
//     builder
//       .addCase(incrementAsync.pending, (state) => {
//         state.status = 'loading';
//       })
//       .addCase(incrementAsync.fulfilled, (state, action) => {
//         state.status = 'idle';
//         state.value += action.payload;
//       });
//   },
// });

// export const { increment, decrement, incrementByAmount } = userSlice.actions;

// export const selectUser = (state) => state.user.user;

// export const incrementIfOdd = (amount) => (dispatch, getState) => {
//   const currentValue = selectUser(getState());
//   if (currentValue % 2 === 1) {
//     dispatch(incrementByAmount(amount));
//   }
// };

// export default userSlice.reducer;

// import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
// import { type } from '@testing-library/user-event/dist/cjs/utility/type.js';

// // Initial state
// const initialState = {
//   value: 0,  // Start with 0 or any other default value you prefer
//   status: 'idle',
// };

// // Simulate an async operation (for example, incrementing the value after a delay)
// export const incrementAsync = createAsyncThunk(
//   'user/incrementAsync',
//   async (amount) => {
//     // Simulate an async API call with a delay
//     const response = await new Promise((resolve) =>
//       setTimeout(() => resolve({ data: amount }), 1000) // mock response with the passed amount
//     );
//     return response.data;  // Return the data as the fulfilled action payload
//   }
// );

// const userSlice = createSlice({
//   name: 'user',
//   initialState,
//   reducers: {
//     login: (state, action) => {
//       state.user = action.payload;  // Normal increment by 1
//     },
//     logout: (state) => {
//       state.value = null;  // Normal decrement by 1
//     },
//     // incrementByAmount: (state, action) => {
//     //   state.value += action.payload;  // Increment by a specific amount passed in the action
//     // },
//   },
//   extraReducers: (builder) => {
//     builder
//       .addCase(incrementAsync.pending, (state) => {
//         state.status = 'loading';  // Set status to 'loading' while waiting for async action
//       })
//       .addCase(incrementAsync.fulfilled, (state, action) => {
//         state.status = 'idle';  // Set status to 'idle' when async action is complete
//         state.value += action.payload;  // Increment value by the returned payload from async action
//       })
//       .addCase(incrementAsync.rejected, (state) => {
//         state.status = 'failed';  // Set status to 'failed' in case of an error
//       });
//   },
// });

// export const { login, logout } = userSlice.actions;

// export const selectUser = (state) => state.user.value;  // Correctly select the user state

// // Optional: You can still have the `incrementIfOdd` logic
// // export const incrementIfOdd = (amount) => (dispatch, getState) => {
// //   const currentValue = selectUser(getState());
// //   if (currentValue % 2 === 1) {
// //     dispatch(incrementByAmount(amount));
// //   }
// // };

// export default userSlice.reducer;

import { createSlice } from "@reduxjs/toolkit";

// Initial state
const initialState = {
  user: null, // Change value to null initially for correct login management
};

const userSlice = createSlice({
  name: "user",
  initialState,
  reducers: {
    login: (state, action) => {
      state.user = action.payload; // Store the user data
    },
    logout: (state) => {
      state.user = null; // Reset user to null when logged out
    },
  },
});

export const { login, logout } = userSlice.actions;

export const selectUser = (state) => state.user.user; // Correctly select user

export default userSlice.reducer;
